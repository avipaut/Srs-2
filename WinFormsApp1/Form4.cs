using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Reflection.Emit;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WinFormsApp1
{
    public partial class Form4 : Form
    {
        public Form4()
        {
            InitializeComponent();
        }

        private void Form4_Load(object sender, EventArgs e)
        {
            label1.MaximumSize = new Size(700, 0);

            label1.Text = "Shell Sort:\r\n\r\nПреимущества:\r\nShell Sort обеспечивает устойчивость относительно входных данных, и его производительность на практике весьма неплоха.\r\nЭффективен для средних и больших массивов данных, особенно когда размер массива значительно превышает количество элементов.\r\nНедостатки:\r\nНе так эффективен для маленьких массивов или уже отсортированных данных.\r\nПараметры (шаги) сортировки могут сильно влиять на производительность, и нахождение оптимальных параметров может быть нетривиальной задачей.\r\nPriority Queue Sort (Heap Sort):\r\n\r\nПреимущества:\r\nHeap Sort гарантирует, что он будет выполнять сортировку в наихудшем случае за O(n log n) времени, что делает его стабильным алгоритмом для сортировки больших объемов данных.\r\nОн не требует дополнительной памяти для сортировки (in-place сортировка).\r\nНедостатки:\r\nНе так быстр в средних и лучших случаях, как некоторые другие алгоритмы, такие как Quick Sort.\r\nМожет потребовать больше времени и сравнений для сортировки, чем некоторые адаптивные алгоритмы, такие как Merge Sort.\r\nQuick Sort:\r\n\r\nПреимущества:\r\nQuick Sort - это один из самых быстрых алгоритмов сортировки в среднем и лучшем случае. Он обычно превосходит другие алгоритмы, такие как Bubble Sort и Insertion Sort.\r\nВ отличие от Shell Sort, Quick Sort хорошо работает как с небольшими, так и с большими массивами данных.\r\nНедостатки:\r\nВ наихудшем случае (когда выбирается плохой опорный элемент), Quick Sort может работать очень медленно и даже вызвать переполнение стека (если не используется итеративная версия).\r\nQuick Sort не гарантирует стабильности порядка элементов.\r\nСравнение:\r\n\r\nЕсли важна производительность и вам необходимо сортировать большие объемы данных, Heap Sort может быть предпочтительным выбором, особенно если дополнительная память ограничена.\r\nЕсли вам нужен хороший компромисс между производительностью и устойчивостью к различным типам входных данных, Shell Sort может быть подходящим выбором.\r\nЕсли важна производительность в среднем и лучшем случае, и вам необходим алгоритм, который хорошо справляется с массивами любого размера, Quick Sort может быть наилучшим выбором.\r\nВыбор алгоритма сортировки зависит от ваших конкретных требований и особенностей данных, с которыми вы работаете.";
            UpdateLabelWidth();
        }
        private void Form5_SizeChanged(object sender, EventArgs e)
        {
            UpdateLabelWidth();
        }

        private void UpdateLabelWidth()
        {
            int maxWidth = this.ClientSize.Width - 20; // Учтем небольшой зазор от края окна
            label1.MaximumSize = new Size(maxWidth, 0);
            label1.AutoSize = true;
        }
    }
}
